### Задания к занятию 10

* Спецификация Rack
* Rack приложения
* Rack Middleware
* Основные компоненты и структура фреймворка



#### Спецификация Rack

Для создания универсального интерфейса между веб серверами/серверами приложений и Ruby фреймворками была создана спецификация Rack. В общем смысле она включает 3 положения:

1. Для того чтобы соответствовать спецификации Rack, приложение Ruby должно представлять собой **любой** объект, отвечающий на метод `call`. Таким объектом может быть экземпляр класса, класс, модуль или даже `Proc` объект.

2. Метод `call` должен принимать единственный аргумент `env` (как правило его именуют именно так), в котором содержится хэш с информацией о запросе (включая HTTP заголовки).

3. Метод `call` должен возвращать **массив из трёх элементов**:

  * Статус ответа
  * Хэш заголовков
  * Объект тела ответа, отвечающий на метод `each` (в самом простом случае это может быть массив)

Пример простейшего Rack приложения:

```ruby
# rackapp.rb
require 'rack'

app = Proc.new { |env| [200, {}, ['Hey, this is Rack, bro!']] }

Rack::Handler::WEBrick.run app
```



#### 1. Методы Rack API

Исследуйте исходный код Gem-а Rack и найдите методы:

Для класса `Rack::Request`:

* Метод возвращающий название агента пользователя

* Метод, возвращающий IP адрес пользователя

* Метод, возвращающий полный URL запроса (включая строку запроса)

Для класса `Rack::Response`:

* Метод добавления данных в тело ответа

* Метод завершающий формирование объекта ответа

* Метод, позволяющий совершить редирект на указанный URL



#### 2. Rack Middleware

Исследуйте исходный код Gem-а Rack и найдите классы или модули Middleware для:

* Установки заголовка `Content-Type` для HTTP ответа на запрос

* Установки заголовка ответа `ETag`



#### 3. It's a lobster, sir!

Запустите Rack приложение лобстер, исходный код которого находится внутри Gem-а Rack.



#### 4. Dice Game on Rack

Превратите приложение `DiceGame` (исходный код в архиве с кодом к заданию) в Rack приложение. Вы можете сделать это на свой вкус, основная идея в том, чтобы управлять ходом игры можно было из клиента, например веб браузера. Следующие положения могут помочь сориентироваться:

* Используйте различные URL для совершения различных действий. Например, `/turn` - для совершения хода, `/finish` - для завершения игры

* Используйте класс `Rack::Request` для создания объекта запроса, а затем – метод `params` для извлечения параметров запроса

* Воспользуйтесь шаблонизатором `ERB` для формирования HTML страниц с ответом на HTTP запрос



### Контакты для связи

* [GeekBrains](http://geekbrains.ru)
* Электронная почта: `spaceflow@gmail.com`
* [Slack](http://geekbrains-ruby0216.slack.com) канал



<!-- Links -->
